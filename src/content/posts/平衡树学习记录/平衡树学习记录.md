---
title: 平衡树学习记录
published: 2025-08-20
description: 记录学习平衡树相关的Treap，FHQ-Treap，Splay等数据结构时的思路，代码及例题题解。
tags: ['算法', '数据结构', '学习记录']
category: 学习笔记
draft: false
---
# 平衡树学习记录
## 二叉搜索树

### 定义

二叉搜索树是一种二叉树形数据结构，定义为：

- 空树是二叉搜索树。
- 若二叉搜索树的左子树不为空，则左子树中的所有点的值都小于根节点的值。
- 若二叉搜索树的右子树不为空，则右子树中的所有点的值都大于根节点的值。
- 二叉搜索树的左右子树均为二叉搜索树。

### 基本操作

根据定义可以发现，二叉搜索树可以维护一些操作。

#### 查找最大/最小值

显然根据定义，最小值为搜索树的最左子链的顶点；最大值为搜索树的最右子链的顶点。

#### 搜索元素

如果我们要查找一个元素，可以从根节点出发，

如果当前节点大于所查找的节点，那么向左子树去查找；

如果当前节点小于所查找的节点，那么向右子树去查找。

直到根节点就为所查找的元素。

#### 插入元素

如果我们要插入一个元素，显然和搜索的逻辑一致，可以从根节点出发，

如果当前节点大于插入元素，那么插入左子树；

如果当前节点小于插入元素，那么插入右子树。

如果当前节点等于插入元素，该节点的值次数增加 $1$ 。

如果当前节点为空，则插入此节点。

#### 求元素排名

显然根据二叉搜索树的性质可得，我们可以首先从根节点一路跳到目标节点。

过程中，如果向右跳，则最终的答案要加上当前节点的左子树大小+当前节点重复次数。

最后的答案加上目标节点左子树的大小 $+1$ 即可。

#### 查找排名为 k 的元素

同理按照求元素排名的方法递归即可。

#### 性质

- 由定义可得，二叉搜索树的中序遍历可以得到一个非递减序列。

### 时间复杂度

显然，二叉搜索树的基本操作的时间复杂度只与树的高度成正比，即为复杂度  $O(h)$。

而对于一个 $n$ 个节点的二叉搜索树，其最优复杂度可以达到 $O(\log n)$，但最坏复杂度会退化为 $O(n)$。

## 平衡树

由于二叉搜索树虽然随机构造的期望高度可以达到 $\log n$，但实际中，搜索树有可能退化成链表。所以我们可以引出平衡树的概念，通过一定的操作维持输得高度（即平衡性），以达到降低时间复杂度的目的。

**平衡性**：一般情况下指一颗搜索树每一个节点的左右子树的高度差最多为 $1$。

### Treap

Treap 是一种 **弱平衡** 的二叉搜索树。

Treap 维护时，每个节点除了维护的 **权值（$val$）** 之外，还额外维护一个随机的 **优先级（$priority$）**。之后构造出**二叉搜索树**，使得 $val$ 符合二叉搜索树的性质。同时构造一个 **堆**，使得 $priority$ 符合堆的性质。

通过这种方式就可以构造出一个 Treap。

![例1](./treap-treap-example.svg)



可以证明，通过这种方式构造的二叉搜索树的期望高度为 $\log n$。（这里笔者就不证明了，可以参考[OI-wiki#树高的证明]([Treap - OI Wiki](https://oiwiki.org/ds/treap/#树高的证明))）

### FHQ-Treap（无旋Treap）

FHQ-Treap 是一种通过**分裂合并**来维护的 Treap，其优点是代码短，利于理解，所以如今被广泛的使用。当然，它存在**常数过大**的缺点。

这种维护方法的本质是因为 Treap 具有结构确定的性质。

首先，由于从一个根节点可以遍历出整个 Treap，所以我们可以将一棵 Treap 看作是一个区间。转化之后，就相当于得出了一个类似线段树的结构。

那么我们可以类比线段树的操作，比如一个区间 $[l,r]$ ，如果想要将其拆分为 $[l,v]$ 和 $[v+1,r]$，那么就相当于将这棵 Treap 按照 $x$ 分裂为两个小 Treap。

#### 分裂

那么具体如何进行分裂操作呢？我们规定查找的值为 $v$，当前节点用 ``p`` 表示。

首先，我们创建两个空 Treap $t1,t2$。

最初，我们位于根节点 ``p`` ，如果给定的 $v$ 不小于  ``p`` 的权值，那么根据二叉搜索树的性质，将 ``p`` 和它的整个左子树全部划分到 $t1$。但是 ``p`` 的右子树中可能存在大于 $v$ 的节点，所以我们可以递归去继续分裂 ``p`` 的右子树，其中小于等于 $v$ 的节点同样划分到 $t1$，作为 ``p`` 的新的右子树。其他部分则划分到 $t2$。

同理若 $v$ 大于 ``p`` 的权值，使用类似的方法分裂即可。

#### 合并

关于合并操作，对于两棵 Treap $t1,t2$，首先要满足 $t1$ 中的所有元素都小于等于 $t2$ 中的元素。（由于我们合并的树一般都是分裂出来的，所以不必单独考虑）

由于两棵 Treap 已经是有序的，我们只需要考虑两棵 Treap **哪个放在上面**，即考虑应该将 $t1$ 作为 $t2$ 的左子树还是将 $t2$ 作为 $t1$ 的右子树。那么显然我们只需要根据 $priority$ 来分讨即可。这样操作就可以保证合并之后的树仍然符合 Treap 的性质。

#### 代码解析

这样，我们就实现了 FHQ-Treap 的核心功能，其的所有操作都建立在分裂合并之上。那么代码就非常好写了。

##### 结构定义

静态开一个结构体用来代表 Treap。

```cpp
struct Point
{
    int l, r;
    int val, rnd;
    int size, sum;
} t[MaxN];
int tot = 0, root = 0;
```

`l` 和 `r` 分别代表左右儿子的节点下标。

`val` 和 `rnd` 分别代表节点的权值和优先值（随机）。

`size` 代表当前的子树大小。

`sum` 代表当前的子树和。

`tot` 用于确定每个点的下标，`root` 代表根节点的下标。

##### 宏定义

为了方便书写，用 ``ls`` 代替 ``t[p].l``，用 ``rs`` 代替 ``t[p].r``。即分别代表左右子树。

##### `pushup` 函数

```cpp
void pushup(int p)
{
    t[p].size = t[ls].size + t[rs].size + 1;
    t[p].sum = t[ls].sum + t[rs].sum + t[p].val;
}
```

类似线段树的 `pushup` ，用于在递归之后综合左右子树的信息并上传至节点 ``p`` 。

##### 按值分裂（`split_v`）

```cpp
void split_v(int p, int v, int &l, int &r)
{
    if (!p)
    {
        l = r = 0;
        return;
    }
    if (t[p].val <= v)
    {
        l = p;
        split_v(rs, v, rs, r);
    }
    else 
    {
        r = p;
        split_v(ls, v, l, ls);
    }
    pushup(p);
}
```

函数 `split_v(p,v,&l,&r)` 的含义为：

- 将树 `p` 按值 `v` 分裂成两棵子树`&l,&r`。
- 使得 `l` 中的所有值都不大于 `v`，`r` 中所有值都全部大于 `v`。

##### 按排名分裂（`split`）

```cpp
void split(int p, int v, int &l, int &r)
{
    if (!p)
    {
        l = r = 0;
        return;
    }
    if (t[ls].size + 1 <= v)
    {
        l = p;
        split(rs, v - (t[ls].size + 1), rs, r);
    }
    else
    {
        r = p;
        split(ls, v, l, ls);
    }
    pushup(p);
}
```



函数 `split(p,v,&l,&r)` 的含义为：

- 将树 `p` 按排名 `v` 分裂成两棵子树`&l,&r`。
- 使得 `l` 中的所有节点在原数组的位置都不大于 `v`，`r` 中所有节点在原数组的位置都全部大于 `v`。