---
import "@fontsource/roboto/400.css";
import "@fontsource/roboto/500.css";
import "@fontsource/roboto/700.css";

import ConfigCarrier from "@components/ConfigCarrier.astro";
import PhotoSwipeInit from "../components/PhotoSwipeInit.svelte";
import { profileConfig, siteConfig } from "@/config";
import {
	AUTO_MODE,
	DARK_MODE,
	DEFAULT_THEME,
	LIGHT_MODE,
	PAGE_WIDTH,
} from "../constants/constants";
import { defaultFavicons } from "../constants/icon";
import type { Favicon } from "../types/config";
import { pathsEqual, url } from "../utils/url-utils";
import "katex/dist/katex.css";
import "@/styles/main.css";

interface Props {
	title?: string;
	banner?: string;
	description?: string;
	lang?: string;
	setOGTypeArticle?: boolean;
}

let { title, banner, description, lang, setOGTypeArticle } = Astro.props;


const BASE_PATH = (() => {
	const raw = import.meta.env.BASE_URL ?? "/";
	const withLeading = raw.startsWith("/") ? raw : `/${raw}`;
	return withLeading.replace(/\/+$/g, "/") || "/";
})();



// apply a class to the body element to decide the height of the banner, only used for initial page load
// Swup can update the body for each page visit, but it's after the page transition, causing a delay for banner height change
// so use Swup hooks instead to change the height immediately when a link is clicked
const isHomePage = pathsEqual(Astro.url.pathname, BASE_PATH);
if (import.meta.env.DEV) {
	console.info("[layout:ssr]", {
		pathname: Astro.url.pathname,
		basePath: BASE_PATH,
		isHomePage,
	});
}

// defines global css variables
// why doing this in Layout instead of GlobalStyles: https://github.com/withastro/astro/issues/6728#issuecomment-1502203757
const configHue = siteConfig.themeColor.hue;

let pageTitle: string;
if (title) {
	pageTitle = `${title} - ${siteConfig.title}`;
} else {
	pageTitle = `${siteConfig.title} - ${siteConfig.subtitle}`;
}

const favicons: Favicon[] =
	siteConfig.favicon.length > 0 ? siteConfig.favicon : defaultFavicons;

// const siteLang = siteConfig.lang.replace('_', '-')
if (!lang) {
	lang = `${siteConfig.lang}`;
}
const siteLang = lang.replace("_", "-");

// Banner offset logic removed
---

<!DOCTYPE html>
<html lang={siteLang} class="bg-[var(--page-bg)] transition text-[14px] md:text-[16px]"
	  data-overlayscrollbars-initialize
>
	<head>

		<title>{pageTitle}</title>

		<meta charset="utf-8">
		<meta name="description" content={description || pageTitle}>
		<meta name="author" content={profileConfig.name}>

		<meta property="og:site_name" content={siteConfig.title}>
		<meta property="og:url" content={Astro.url}>
		<meta property="og:title" content={pageTitle}>
		<meta property="og:description" content={description || pageTitle}>
		{setOGTypeArticle ? (
        <meta property="og:type" content="article" />
        ) : (
        <meta property="og:type" content="website" />
        )}

		<meta name="twitter:card" content="summary_large_image">
		<meta property="twitter:url" content={Astro.url}>
		<meta name="twitter:title" content={pageTitle}>
		<meta name="twitter:description" content={description || pageTitle}>

		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		{favicons.map(favicon => (
			<link rel="icon"
				  href={favicon.src.startsWith('/') ? url(favicon.src) : favicon.src}
				  sizes={favicon.sizes}
				  media={favicon.theme && `(prefers-color-scheme: ${favicon.theme})`}
			/>
		))}

		<!-- Set the theme before the page is rendered to avoid a flash -->
		<script is:inline define:vars={{DEFAULT_THEME, LIGHT_MODE, DARK_MODE, AUTO_MODE, PAGE_WIDTH, configHue}}>
			// Load the theme from local storage
			const theme = localStorage.getItem('theme') || DEFAULT_THEME;
			switch (theme) {
				case LIGHT_MODE:
					document.documentElement.classList.remove('dark');
					break
				case DARK_MODE:
					document.documentElement.classList.add('dark');
					break
				case AUTO_MODE:
					if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
						document.documentElement.classList.add('dark');
					} else {
						document.documentElement.classList.remove('dark');
					}
			}

			// Load the hue from local storage
			const hue = localStorage.getItem('hue') || configHue;
			document.documentElement.style.setProperty('--hue', hue);
		</script>
		<style define:vars={{
			configHue,
			'page-width': `${PAGE_WIDTH}rem`,
		}}></style>  <!-- defines global css variables. This will be applied to <html> <body> and some other elements idk why -->


		<slot name="head"></slot>

		<link rel="alternate" type="application/rss+xml" title={profileConfig.name} href={`${Astro.site}rss.xml`}/>

	</head>
	<body class=" min-h-screen transition " class:list={[{"lg:is-home": isHomePage}]}
		  data-overlayscrollbars-initialize
	>
		<ConfigCarrier></ConfigCarrier>
		<div id="layout-root">
			<slot />
		</div>

		<!-- increase the page height during page transition to prevent the scrolling animation from jumping -->
		<div id="page-height-extend" class="hidden h-[300vh]"></div>
		<PhotoSwipeInit client:load />
	</body>
</html>



<script>
import 'overlayscrollbars/overlayscrollbars.css';
import {
	OverlayScrollbars,
	// ScrollbarsHidingPlugin,
	// SizeObserverPlugin,
	// ClickScrollPlugin
} from 'overlayscrollbars';
import {getHue, getStoredTheme, setHue, setTheme} from "../utils/setting-utils";

// Banner constants removed
import { siteConfig } from '../config';

/* Preload fonts */
// (async function() {
// 	try {
// 		await Promise.all([
// 			document.fonts.load("400 1em Roboto"),
// 			document.fonts.load("700 1em Roboto"),
// 		]);
// 		document.body.classList.remove("hidden");
// 	} catch (error) {
// 		console.log("Failed to load fonts:", error);
// 	}
// })();

/* TODO This is a temporary solution for style flicker issue when the transition is activated */
/* issue link: https://github.com/withastro/astro/issues/8711, the solution get from here too */
/* update: fixed in Astro 3.2.4 */
/*
function disableAnimation() {
	const css = document.createElement('style')
	css.appendChild(
		document.createTextNode(
			`*{
              -webkit-transition:none!important;
              -moz-transition:none!important;
              -o-transition:none!important;
              -ms-transition:none!important;
              transition:none!important
              }`
		)
	)
	document.head.appendChild(css)

	return () => {
		// Force restyle
		;(() => window.getComputedStyle(document.body))()

		// Wait for next tick before removing
		setTimeout(() => {
			document.head.removeChild(css)
		}, 1)
	}
}
*/

// Banner functionality removed

/**
 * Close a floating panel when clicking outside of the provided ignore targets.
 * @param {string} panel
 * @param {string[]} ignores
 */
function setClickOutsideToClose(panel, ignores) {
	document.addEventListener("click", event => {
		const panelDom = document.getElementById(panel);
		if (!panelDom) {
			return;
		}
		const tDom = event.target;
		if (!(tDom instanceof Node)) return; 		// Ensure the event target is an HTML Node
		for (const ig of ignores) {
			const ie = document.getElementById(ig)
			if (ie == tDom || (ie?.contains(tDom))) {
				return;
			}
		}
		panelDom.classList.add("float-panel-closed");
	});
}
setClickOutsideToClose("display-setting", ["display-setting", "display-settings-switch"])
setClickOutsideToClose("nav-menu-panel", ["nav-menu-panel", "nav-menu-switch"])
setClickOutsideToClose("search-panel", ["search-panel", "search-bar", "search-switch"])


function loadTheme() {
	const theme = getStoredTheme()
	setTheme(theme)
}

function loadHue() {
	setHue(getHue())
}

function initCustomScrollbar() {
	const bodyElement = document.querySelector('body');
	if (!bodyElement) return;
	OverlayScrollbars(
		// docs say that a initialization to the body element would affect native functionality like window.scrollTo
		// but just leave it here for now
		{
			target: bodyElement,
			cancel: {
				nativeScrollbarsOverlaid: true,    // don't initialize the overlay scrollbar if there is a native one
			}
		}, {
		scrollbars: {
			theme: 'scrollbar-base scrollbar-auto py-1',
			autoHide: 'move',
			autoHideDelay: 500,
			autoHideSuspend: false,
		},
	});

	const katexElements = document.querySelectorAll('.katex-display');

	const katexObserverOptions = {
		root: null,
		rootMargin: '100px',
		threshold: 0.1
	};

	const processKatexElement = (element) => {
		if (!element.parentNode) return;
		if (element.hasAttribute('data-scrollbar-initialized')) return;

		const container = document.createElement('div');
		container.className = 'katex-display-container';
		container.setAttribute('aria-label', 'scrollable container for formulas');

		element.parentNode.insertBefore(container, element);
		container.appendChild(element);

		OverlayScrollbars(container, {
			scrollbars: {
				theme: 'scrollbar-base scrollbar-auto',
				autoHide: 'leave',
				autoHideDelay: 500,
				autoHideSuspend: false
			}
		});

		element.setAttribute('data-scrollbar-initialized', 'true');
	};

	const katexObserver = new IntersectionObserver((entries, observer) => {
		entries.forEach(entry => {
			if (entry.isIntersecting) {
			processKatexElement(entry.target);
			observer.unobserve(entry.target);
			}
		});
	}, katexObserverOptions);

	katexElements.forEach(element => {
		katexObserver.observe(element);
	});
}

// showBanner function removed

function init() {
	// disableAnimation()()		// TODO
	loadTheme();
	loadHue();
	initCustomScrollbar();
}

/* Load settings when entering the site */
const bootstrap = () => {
	init();
};

if (document.readyState === "complete") {
	queueMicrotask(bootstrap);
} else {
	window.addEventListener("load", bootstrap, { once: true });
}

const IS_DEV = import.meta.env.DEV;
const DEBUG_PREFIX = "[layout]";
const debugLog = (...messages) => {
	if (!IS_DEV) {
		return;
	}
	console.info(DEBUG_PREFIX, ...messages);
};

const normalizePath = (value) => {
	const withLeading = value.startsWith("/") ? value : `/${value}`;
	return withLeading.replace(/\/+$/g, "/") || "/";
};

const CLIENT_BASE_PATH = normalizePath(import.meta.env.BASE_URL ?? "/");
const homePath = normalizePath(CLIENT_BASE_PATH);
if (IS_DEV) {
	debugLog("config", {
		clientBasePath: CLIENT_BASE_PATH,
		homePath,
		currentHref: typeof window !== "undefined" ? window.location.href : "window-unavailable",
	});
}

const getPathname = (target) => {
	try {
		return new URL(target, window.location.origin).pathname;
	} catch {
		return target;
	}
};

const isHomeTarget = (target) => {
	const targetPath = normalizePath(getPathname(target)).toLowerCase();
	return targetPath === homePath.toLowerCase();
};

const updateHomeClass = (target) => {
	const bodyElement = document.querySelector('body');
	if (!bodyElement) {
		return;
	}
	const shouldApply = target ? isHomeTarget(target) : isHomeTarget(window.location.href);
	bodyElement.classList.toggle('lg:is-home', shouldApply);
	debugLog('updateHomeClass', { target: target ?? window.location.href, shouldApply, classList: bodyElement.className });
	return shouldApply;
};

const setup = () => {
	// TODO: temp solution to change the height of the banner
/*
	window.swup.hooks.on('animation:out:start', () => {
		const path = window.location.pathname
		const body = document.querySelector('body')
		if (path[path.length - 1] === '/' && !body.classList.contains('is-home')) {
			body.classList.add('is-home')
		} else if (path[path.length - 1] !== '/' && body.classList.contains('is-home')) {
			body.classList.remove('is-home')
		}
	})
*/
	window.swup.hooks.on('link:click', () => {
		// Remove the delay for the first time page load
		document.documentElement.style.setProperty('--content-delay', '0ms')

		// Banner navbar overlap logic removed
		debugLog('link:click', { location: window.location.href });
	})
	window.swup.hooks.on('content:replace', initCustomScrollbar)
	window.swup.hooks.on('visit:start', (visit) => {
		// change banner height immediately when a link is clicked
		debugLog('visit:start', { to: visit.to?.url });
		updateHomeClass(visit.to.url);

		// increase the page height during page transition to prevent the scrolling animation from jumping
		const heightExtend = document.getElementById('page-height-extend')
		if (heightExtend) {
			heightExtend.classList.remove('hidden')
		}

		// Hide the TOC while scrolling back to top
		let toc = document.getElementById('toc-wrapper');
		if (toc) {
			toc.classList.add('toc-not-ready')
		}
	});
	window.swup.hooks.on('page:view', () => {
		const applied = updateHomeClass();
		debugLog('page:view', { location: window.location.href, isHome: applied });
		// hide the temp high element when the transition is done
		const heightExtend = document.getElementById('page-height-extend')
		if (heightExtend) {
			heightExtend.classList.remove('hidden')
		}
	});
	window.swup.hooks.on('visit:end', (_visit) => {
		setTimeout(() => {
			const heightExtend = document.getElementById('page-height-extend')
			if (heightExtend) {
				heightExtend.classList.add('hidden')
			}

            // Just make the transition looks better
            const toc = document.getElementById('toc-wrapper');
            if (toc) {
                toc.classList.remove('toc-not-ready')
            }
        }, 200)
	});
}

const ensureSwupHooks = () => {
	if (window.__layoutSwupHooksRegistered) {
		return;
	}

	let pollId;
	let hasLoggedWait = false;

	const trySetup = () => {
		if (!window?.swup?.hooks) {
			return false;
		}
		if (pollId !== undefined) {
			window.clearInterval(pollId);
			pollId = undefined;
		}
		window.__layoutSwupHooksRegistered = true;
		debugLog('Swup hooks detected', { containers: window.swup?.options?.containers });
		setup();
		return true;
	};

	if (trySetup()) {
		debugLog('Swup hooks registered immediately');
		return;
	}

	const handleEnable = () => {
		if (trySetup()) {
			document.removeEventListener('swup:enable', handleEnable);
			window.removeEventListener('swup:enable', handleEnable);
			window.removeEventListener('load', handleEnable);
		}
	};

	document.addEventListener('swup:enable', handleEnable);
	window.addEventListener('swup:enable', handleEnable);
	window.addEventListener('load', handleEnable);

	pollId = window.setInterval(() => {
		if (!hasLoggedWait) {
			debugLog('Waiting for Swup hooks to initialize');
			hasLoggedWait = true;
		}
		if (trySetup()) {
			document.removeEventListener('swup:enable', handleEnable);
			window.removeEventListener('swup:enable', handleEnable);
			window.removeEventListener('load', handleEnable);
		}
	}, 50);
	setTimeout(handleEnable, 0);
};

ensureSwupHooks();
const initialApplied = updateHomeClass();
debugLog('initial-state', { location: window.location.href, isHome: initialApplied });
window.addEventListener('popstate', () => {
	const applied = updateHomeClass();
	debugLog('popstate', { location: window.location.href, isHome: applied });
});

let backToTopBtn = document.getElementById('back-to-top-btn');
let toc = document.getElementById('toc-wrapper');
let navbar = document.getElementById('navbar-wrapper')
function scrollFunction() {
	// Banner-related scroll functionality removed
	if (backToTopBtn) {
		if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
			backToTopBtn.classList.remove('hide')
		} else {
			backToTopBtn.classList.add('hide')
		}
	}
}
window.onscroll = scrollFunction

// Banner resize logic removed

</script>

