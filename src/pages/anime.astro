---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import Layout from "../layouts/Layout.astro";
import MainGridLayout from "../layouts/MainGridLayout.astro";
import { animePageConfig } from "../config";
import localAnimeList, { type AnimeItem } from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";

if (!animePageConfig.enable) {
	return Astro.redirect("/404/");
}

const BANGUMI_USER_ID = animePageConfig.bangumiUserId || "your-user-id";
const BANGUMI_API_BASE = "https://api.bgm.tv";
const ANIME_MODE = animePageConfig.mode || "bangumi";

type RemoteAnimeItem = {
	title?: string;
	followStatus?: { code?: number; label?: string };
	cover?: string | null;
	evaluate?: string | null;
	totalEpisodes?: number | null;
	watchedEpisodes?: number | null;
	rating?: { score?: number | null } | null;
	areas?: string[] | null;
	styles?: string[] | null;
	publish?: {
		releaseDate?: string | null;
		pubTime?: string | null;
	};
	latestEpisode?: {
		index?: string | null;
	} | null;
	progressRaw?: string | null;
	url?: string | null;
};

type RemoteApiResponse = {
	items?: RemoteAnimeItem[];
	list?: RemoteAnimeItem[];
};

function parseDigits(text?: string | null) {
	if (!text) return null;
	const match = text.match(/(\d+)/);
	return match ? Number.parseInt(match[1], 10) : null;
}

function mapRemoteStatus(
	code?: number | null,
	label?: string | null,
): AnimeItem["status"] {
	switch (code) {
		case 1:
			return "planned";
		case 2:
			return "completed";
		case 3:
			return "watching";
		default: {
			const normalized = label?.toLowerCase();
			if (normalized === "want") return "planned";
			if (normalized === "watched") return "completed";
			if (normalized === "watching") return "watching";
			return "watching";
		}
	}
}

function transformRemoteItem(item: RemoteAnimeItem): AnimeItem {
	const releaseDate =
		item.publish?.releaseDate || item.publish?.pubTime || undefined;
	const totalEpisodes =
		item.totalEpisodes ?? parseDigits(item.latestEpisode?.index) ?? 0;
	const watchedEpisodes =
		item.watchedEpisodes ?? parseDigits(item.progressRaw ?? "") ?? 0;
	const year = releaseDate ? releaseDate.slice(0, 4) : "Unknown";
	return {
		title: item.title ?? "Unknown Title",
		status: mapRemoteStatus(item.followStatus?.code, item.followStatus?.label),
		rating: typeof item.rating?.score === "number" ? item.rating.score : 0,
		cover: item.cover ?? "/assets/anime/default.webp",
		description: item.evaluate ?? "",
		episodes:
			totalEpisodes > 0 ? `${totalEpisodes} episodes` : "Unknown episodes",
		year: year,
		genre: item.styles ?? [],
		studio:
			item.areas && item.areas.length > 0 ? item.areas[0] : "Unknown Studio",
		link: item.url ?? "#",
		progress: watchedEpisodes,
		totalEpisodes: totalEpisodes,
		startDate: releaseDate ?? "",
		endDate: releaseDate ?? "",
	};
}

async function fetchRemoteAnimeList(): Promise<AnimeItem[]> {
	if (!animePageConfig.remoteEndpoint) {
		console.warn("Remote mode enabled but remoteEndpoint is missing");
		return [];
	}
	try {
		const url = new URL(animePageConfig.remoteEndpoint);
		const existingStatusParams = url.searchParams.getAll("status").length;
		if (
			animePageConfig.remoteStatuses &&
			animePageConfig.remoteStatuses.length > 0 &&
			existingStatusParams === 0
		) {
			for (const status of animePageConfig.remoteStatuses) {
				url.searchParams.append("status", status);
			}
		}
		const response = await fetch(url.toString(), {
			headers: {
				Accept: "application/json",
			},
		});
		if (!response.ok) {
			throw new Error(`Remote API error: ${response.status}`);
		}
		const payload = (await response.json()) as RemoteApiResponse;
		const list = Array.isArray(payload.items)
			? payload.items
			: Array.isArray(payload.list)
				? payload.list
				: [];
		return list.map(transformRemoteItem);
	} catch (error) {
		console.error("Failed to fetch remote anime list:", error);
		return [];
	}
}

async function fetchSubjectPersons(subjectId: number) {
	try {
		const response = await fetch(
			`${BANGUMI_API_BASE}/v0/subjects/${subjectId}/persons`,
		);
		const data = await response.json();
		return Array.isArray(data) ? data : [];
	} catch (error) {
		console.error(`Error fetching subject ${subjectId} persons:`, error);
		return [];
	}
}

async function fetchBangumiCollection(
	userId: string,
	subjectType: number,
	type: number,
) {
	try {
		let allData: any[] = [];
		let offset = 0;
		const limit = 50;
		let hasMore = true;

		while (hasMore) {
			const response = await fetch(
				`${BANGUMI_API_BASE}/v0/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${limit}&offset=${offset}`,
			);
			if (!response.ok) {
				throw new Error(`Bangumi API error: ${response.status}`);
			}
			const data = await response.json();

			if (data.data && data.data.length > 0) {
				allData = [...allData, ...data.data];
			}
			if (!data.data || data.data.length < limit) {
				hasMore = false;
			} else {
				offset += limit;
			}
			await new Promise((resolve) => setTimeout(resolve, 100));
		}
		return { data: allData };
	} catch (error) {
		console.error("Error fetching Bangumi data:", error);
		return null;
	}
}

async function processBangumiData(
	data: any,
	status: AnimeItem["status"],
): Promise<AnimeItem[]> {
	if (!data || !data.data) return [];

	const detailedItems = await Promise.all(
		data.data.map(async (item: any) => {
			const subjectPersons = await fetchSubjectPersons(item.subject_id);
			const year = item.subject?.date || "Unknown";
			const rating = item.rate ? Number.parseFloat(item.rate.toFixed(1)) : 0;
			const progress = item.ep_status || 0;
			const totalEpisodes = item.subject?.eps || progress || 0;
			let studio = "Unknown";
			if (Array.isArray(subjectPersons)) {
				const priorities = ["Âä®ÁîªÂà∂‰Ωú", "Ë£Ω‰Ωú", "Âà∂‰Ωú"];
				for (const relation of priorities) {
					const match = subjectPersons.find(
						(person) => person.relation === relation,
					);
					if (match?.name) {
						studio = match.name;
						break;
					}
				}
			}

			return {
				title: item.subject?.name_cn || item.subject?.name || "Unknown Title",
				status,
				rating,
				cover: item.subject?.images?.medium || "/assets/anime/default.webp",
				description: (
					item.subject?.short_summary ||
					item.subject?.name_cn ||
					""
				).trimStart(),
				episodes: `${totalEpisodes} episodes`,
				year,
				genre: item.subject?.tags
					? item.subject.tags.slice(0, 3).map((tag: any) => tag.name)
					: ["Unknown"],
				studio,
				link: item.subject?.id
					? `https://bgm.tv/subject/${item.subject.id}`
					: "#",
				progress,
				totalEpisodes,
				startDate: item.subject?.date || "",
				endDate: item.subject?.date || "",
			} satisfies AnimeItem;
		}),
	);
	return detailedItems;
}

let animeList: AnimeItem[] = [];
if (ANIME_MODE === "local") {
	animeList = localAnimeList;
} else if (ANIME_MODE === "remote") {
	animeList = await fetchRemoteAnimeList();
} else {
	const watchingData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 3);
	const completedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 2);

	const watchingList = watchingData
		? await processBangumiData(watchingData, "watching")
		: [];
	const completedList = completedData
		? await processBangumiData(completedData, "completed")
		: [];

	animeList = [...watchingList, ...completedList];
}

function getStatusInfo(status: AnimeItem["status"]) {
	switch (status) {
		case "watching":
			return {
				text: i18n(I18nKey.animeStatusWatching),
				class:
					"bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
				icon: "‚ñ∂",
			};
		case "completed":
			return {
				text: i18n(I18nKey.animeStatusCompleted),
				class:
					"bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
				icon: "‚úì",
			};
		case "planned":
			return {
				text: i18n(I18nKey.animeStatusPlanned),
				class:
					"bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300",
				icon: "‚è∞",
			};
		case "onhold":
			return {
				text: i18n(I18nKey.animeStatusOnHold),
				class:
					"bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300",
				icon: "‚è∏",
			};
		case "dropped":
			return {
				text: i18n(I18nKey.animeStatusDropped),
				class:
					"bg-rose-100 text-rose-700 dark:bg-rose-900/30 dark:text-rose-300",
				icon: "‚úï",
			};
		default:
			return {
				text: status,
				class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
				icon: "?",
			};
	}
}
---

<Layout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
  <MainGridLayout>
    <div class="anime-page max-w-7xl mx-auto px-4 py-8">
      <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
        <div class="card-base z-10 px-6 md:px-9 py-6 relative w-full">
          <div class="relative w-full mb-8">
            <div class="mb-6">
              <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)] before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
                {i18n(I18nKey.animeTitle)}
              </h1>
              <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
            </div>

            <div class="mb-6">
              <div class="filter-container flex flex-wrap gap-2">
                <button class="filter-tag active" data-status="all">{i18n(I18nKey.animeFilterAll)}</button>
                <button class="filter-tag" data-status="watching">{i18n(I18nKey.animeStatusWatching)}</button>
                <button class="filter-tag" data-status="completed">{i18n(I18nKey.animeStatusCompleted)}</button>
                <button class="filter-tag" data-status="planned">{i18n(I18nKey.animeStatusPlanned)}</button>
                {ANIME_MODE === 'bangumi' && (
                  <>
                    <button class="filter-tag" data-status="onhold">{i18n(I18nKey.animeStatusOnHold)}</button>
                    <button class="filter-tag" data-status="dropped">{i18n(I18nKey.animeStatusDropped)}</button>
                  </>
                )}
              </div>
            </div>
          </div>

          <div class="mb-8">
            {ANIME_MODE !== 'local' && BANGUMI_USER_ID === 'your-user-id' ? (
              <div class="text-center py-12">
                <div class="text-5xl mb-4">üò¢</div>
                <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
                  {i18n(I18nKey.animeEmpty)}
                </h3>
                <p class="text-black/60 dark:text-white/60">
                  {i18n(I18nKey.animeEmptyBangumi)}
                </p>
              </div>
            ) : animeList.length > 0 ? (
              <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6">
                {animeList.map((anime) => {
                  const statusInfo = getStatusInfo(anime.status);
                  const progressPercent = anime.totalEpisodes > 0 ? (anime.progress / anime.totalEpisodes) * 100 : 0;

                  return (
                    <div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]" data-anime-status={anime.status}>
                      <div class="relative aspect-[2/3] overflow-hidden">
                        <a href={anime.link} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                          <ImageWrapper
                            src={anime.cover}
                            alt={anime.title}
                            class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                          />
                          <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                            <div class="absolute inset-0 flex items-center justify-center">
                              <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                                <svg class="w-6 h-6 text-gray-800 ml-1" fill="currentColor" viewBox="0 0 24 24">
                                  <path d="M8 5v14l11-7z"></path>
                                </svg>
                              </div>
                            </div>
                          </div>
                        </a>

                        <div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
                          <span class="mr-1">{statusInfo.icon}</span>
                          <span>{statusInfo.text}</span>
                        </div>

                        <div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
                          <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                          </svg>
                          <span>{anime.rating}</span>
                        </div>

                        {anime.status === 'watching' && (
                          <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                            <div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
                              <div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300" style={`width: ${progressPercent}%`}></div>
                            </div>
                            <div class="text-white text-xs font-medium">
                              {anime.progress}/{anime.totalEpisodes} ({Math.round(progressPercent)}%)
                            </div>
                          </div>
                        )}
                      </div>

                      <div class="p-3">
                        <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">{anime.title}</h3>
                        <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">{anime.description}</p>

                        <div class="space-y-1 text-xs">
                          <div class="flex justify-between">
                            <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeYear)}</span>
                            <span class="text-black/70 dark:text-white/70">{anime.year}</span>
                          </div>
                          <div class="flex justify-between">
                            <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeStudio)}</span>
                            <span class="text-black/70 dark:text-white/70 truncate ml-2">{anime.studio}</span>
                          </div>
                          <div class="flex flex-wrap gap-1 mt-2">
                            {anime.genre.map((g) => (
                              <span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">{g}</span>
                            ))}
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            ) : (
              <div class="text-center py-12">
                <div class="text-5xl mb-4">üò¢</div>
                <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
                  {i18n(I18nKey.animeEmpty)}
                </h3>
                <p class="text-black/60 dark:text-white/60">
                  {ANIME_MODE === 'local' ? i18n(I18nKey.animeEmptyLocal) : i18n(I18nKey.animeEmptyBangumi)}
                </p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  </MainGridLayout>
</Layout>

<style>
  .filter-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .filter-tag {
    padding: 0.5rem 1rem;
    border: 1px solid var(--line-divider);
    border-radius: var(--radius-large);
    background: var(--btn-regular-bg);
    color: var(--btn-content);
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
  }

  .filter-tag:hover:not(.active) {
    background: var(--btn-hover-bg);
    border-color: var(--primary);
    transform: translateY(-1px);
  }

  .filter-tag.active {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
  }

  .filter-tag.active:hover {
    background: var(--primary) !important;
    color: white !important;
    border-color: var(--primary) !important;
    transform: translateY(-1px);
  }

  [data-anime-status] {
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  }

  [data-anime-status].anime-hidden {
    display: none;
  }

  [data-anime-status].anime-animating {
    transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  }

  [data-anime-status].anime-fade-out {
    opacity: 0;
    transform: scale(0.8);
    pointer-events: none;
    transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  [data-anime-status].anime-fade-in {
    opacity: 0;
    transform: scale(0.8);
  }

  [data-anime-status].anime-fade-in-active {
    opacity: 1;
    transform: scale(1);
  }
</style>

<script is:inline>
  let filterEventListeners = [];

  function initFilterButtons() {
    const filterTags = document.querySelectorAll('.filter-tag');

    filterEventListeners.forEach(listener => {
      const [element, type, handler] = listener;
      element.removeEventListener(type, handler);
    });
    filterEventListeners = [];

    filterTags.forEach(tag => {
      const clickHandler = function () {
        if (this.classList.contains('active')) return;

        filterTags.forEach(t => t.classList.remove('active'));
        this.classList.add('active');

        const status = this.getAttribute('data-status');
        const animeItems = Array.from(document.querySelectorAll('[data-anime-status]'));

        const firstPositions = new Map();
        animeItems.forEach(item => {
          const rect = item.getBoundingClientRect();
          firstPositions.set(item, {
            left: rect.left,
            top: rect.top,
          });
        });

        const itemsToHide = [];
        const itemsToShow = [];
        const itemsToKeep = [];

        animeItems.forEach(item => {
          const itemStatus = item.getAttribute('data-anime-status');
          const shouldShow = status === 'all' || itemStatus === status;
          const isCurrentlyVisible = !item.classList.contains('anime-hidden');

          if (shouldShow) {
            if (isCurrentlyVisible) {
              itemsToKeep.push(item);
            } else {
              itemsToShow.push(item);
            }
          } else if (isCurrentlyVisible) {
            itemsToHide.push(item);
          }
        });

        itemsToHide.forEach(item => {
          item.classList.add('anime-fade-out');
        });

        setTimeout(() => {
          itemsToHide.forEach(item => {
            item.classList.add('anime-hidden');
            item.classList.remove('anime-fade-out');
          });

          itemsToShow.forEach(item => {
            item.classList.remove('anime-hidden');
            item.classList.add('anime-fade-in');
            item.style.opacity = '0';
            item.style.transform = 'scale(0.8)';
            item.style.transition = 'none';
          });

          requestAnimationFrame(() => {
            const lastPositions = new Map();
            [...itemsToKeep, ...itemsToShow].forEach(item => {
              const rect = item.getBoundingClientRect();
              lastPositions.set(item, {
                left: rect.left,
                top: rect.top,
              });
            });

            itemsToKeep.forEach(item => {
              const first = firstPositions.get(item);
              const last = lastPositions.get(item);
              if (first && last) {
                const deltaX = first.left - last.left;
                const deltaY = first.top - last.top;
                item.style.transition = 'none';
                item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
              }
            });

            requestAnimationFrame(() => {
              const allItems = [...itemsToKeep, ...itemsToShow];

              allItems.forEach((item, index) => {
                setTimeout(() => {
                  item.classList.add('anime-animating');

                  if (itemsToKeep.includes(item)) {
                    item.style.transition = '';
                    item.style.transform = '';
                  }

                  if (itemsToShow.includes(item)) {
                    item.classList.remove('anime-fade-in');
                    item.classList.add('anime-fade-in-active');
                    item.style.transition = '';
                    item.style.opacity = '1';
                    item.style.transform = 'scale(1)';
                  }
                }, index * 20);
              });

              setTimeout(() => {
                allItems.forEach(item => {
                  item.classList.remove('anime-animating', 'anime-fade-in-active');
                  item.style.transition = '';
                  item.style.transform = '';
                  item.style.opacity = '';
                });
              }, 500 + allItems.length * 20);
            });
          });
        }, 300);
      };

      tag.addEventListener('click', clickHandler);
      filterEventListeners.push([tag, 'click', clickHandler]);
    });
  }

  document.addEventListener('DOMContentLoaded', initFilterButtons);

  function setupSwupListeners() {
    if (window.swup) {
      window.swup.hooks.on('content:replace', function () {
        setTimeout(initFilterButtons, 150);
      });

      window.swup.hooks.on('page:view', function () {
        setTimeout(initFilterButtons, 150);
      });

      window.swup.hooks.on('animation:in:end', function () {
        setTimeout(initFilterButtons, 200);
      });
    }
  }

  if (typeof window !== 'undefined') {
    if (window.swup) {
      setupSwupListeners();
    } else {
      document.addEventListener('swup:enable', function () {
        setupSwupListeners();
      });
    }
  }
</script>
