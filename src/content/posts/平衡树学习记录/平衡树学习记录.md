---
title: 平衡树学习记录
published: 2025-08-20
description: 记录学习平衡树相关的Treap，FHQ-Treap，Splay等数据结构时的思路，代码及例题题解。
tags: ['算法', '数据结构', '学习记录']
category: 学习笔记
draft: false
---
# 平衡树学习记录
## 二叉搜索树

### 定义

二叉搜索树是一种二叉树形数据结构，定义为：

- 空树是二叉搜索树。
- 若二叉搜索树的左子树不为空，则左子树中的所有点的值都小于根节点的值。
- 若二叉搜索树的右子树不为空，则右子树中的所有点的值都大于根节点的值。
- 二叉搜索树的左右子树均为二叉搜索树。

### 基本操作

根据定义可以发现，二叉搜索树可以维护一些操作。

#### 查找最大/最小值

显然根据定义，最小值为搜索树的最左子链的顶点；最大值为搜索树的最右子链的顶点。

#### 搜索元素

如果我们要查找一个元素，可以从根节点出发，

如果当前节点大于所查找的节点，那么向左子树去查找；

如果当前节点小于所查找的节点，那么向右子树去查找。

直到根节点就为所查找的元素。

#### 插入元素

如果我们要插入一个元素，显然和搜索的逻辑一致，可以从根节点出发，

如果当前节点大于插入元素，那么插入左子树；

如果当前节点小于插入元素，那么插入右子树。

如果当前节点等于插入元素，该节点的值次数增加 $1$ 。

如果当前节点为空，则插入此节点。

#### 求元素排名

显然根据二叉搜索树的性质可得，我们可以首先从根节点一路跳到目标节点。

过程中，如果向右跳，则最终的答案要加上当前节点的左子树大小+当前节点重复次数。

最后的答案加上目标节点左子树的大小 $+1$ 即可。

#### 查找排名为 k 的元素

同理按照求元素排名的方法递归即可。

#### 性质

- 由定义可得，二叉搜索树的中序遍历可以得到一个非递减序列。

### 时间复杂度

显然，二叉搜索树的基本操作的时间复杂度只与树的高度成正比，即为复杂度  $O(h)$。

而对于一个 $n$ 个节点的二叉搜索树，其最优复杂度可以达到 $O(\log n)$，但最坏复杂度会退化为 $O(n)$。

## 平衡树

由于二叉搜索树虽然随机构造的期望高度可以达到 $\log n$，但实际中，搜索树有可能退化成链表。所以我们可以引出平衡树的概念，通过一定的操作维持输得高度（即平衡性），以达到降低时间复杂度的目的。

**平衡性**：一般情况下指一颗搜索树每一个节点的左右子树的高度差最多为 $1$。

### Treap

Treap 是一种 **弱平衡** 的二叉搜索树。

Treap 维护时，每个节点除了维护的 **权值（$val$）** 之外，还额外维护一个随机的 **优先级（$priority$）**。之后构造出**二叉搜索树**，使得 $val$ 符合二叉搜索树的性质。同时构造一个 **堆**，使得 $priority$ 符合堆的性质。

通过这种方式就可以构造出一个 Treap。

![例1](./treap-treap-example.svg)



可以证明，通过这种方式构造的二叉搜索树的期望高度为 $\log n$。（这里笔者就不证明了，可以参考[OI-wiki#树高的证明]([Treap - OI Wiki](https://oiwiki.org/ds/treap/#树高的证明))）

### FHQ-Treap（无旋Treap）

FHQ-Treap 是一种通过**分裂合并**来维护的 Treap，其优点是代码短，利于理解，所以如今被广泛的使用。当然，它存在**常数过大**的缺点。

这种维护方法的本质是因为 Treap 具有结构确定的性质。

首先，由于从一个根节点可以遍历出整个 Treap，所以我们可以将一棵 Treap 看作是一个区间。转化之后，就相当于得出了一个类似线段树的结构。

那么我们可以类比线段树的操作，比如一个区间 $[l,r]$ ，如果想要将其拆分为 $[l,v]$ 和 $[v+1,r]$，那么就相当于将这棵 Treap 按照 $x$ 分裂为两个小 Treap。

#### 分裂

那么具体如何进行分裂操作呢？我们规定查找的值为 $v$，当前节点用 ``p`` 表示。

首先，我们创建两个空 Treap $t1,t2$。

最初，我们位于根节点 ``p`` ，如果给定的 $v$ 不小于  ``p`` 的权值，那么根据二叉搜索树的性质，将 ``p`` 和它的整个左子树全部划分到 $t1$。但是 ``p`` 的右子树中可能存在大于 $v$ 的节点，所以我们可以递归去继续分裂 ``p`` 的右子树，其中小于等于 $v$ 的节点同样划分到 $t1$，作为 ``p`` 的新的右子树。其他部分则划分到 $t2$。

同理若 $v$ 大于 ``p`` 的权值，使用类似的方法分裂即可。

#### 合并

关于合并操作，对于两棵 Treap $t1,t2$，首先要满足 $t1$ 中的所有元素都小于等于 $t2$ 中的元素。（由于我们合并的树一般都是分裂出来的，所以不必单独考虑）

由于两棵 Treap 已经是有序的，我们只需要考虑两棵 Treap **哪个放在上面**，即考虑应该将 $t1$ 作为 $t2$ 的左子树还是将 $t2$ 作为 $t1$ 的右子树。那么显然我们只需要根据 $priority$ 来分讨即可。这样操作就可以保证合并之后的树仍然符合 Treap 的性质。

#### 代码解析

这样，我们就实现了 FHQ-Treap 的核心功能，其的所有操作都建立在分裂合并之上。那么代码就非常好写了。

##### 结构定义

静态开一个结构体用来代表 Treap。

```cpp
struct Point
{
    int l, r;
    int val, rnd;
    int size, sum;
} t[MaxN];
int tot = 0, root = 0;
```

`l` 和 `r` 分别代表左右儿子的节点下标。

`val` 和 `rnd` 分别代表节点的权值和优先值（随机）。

`size` 代表当前的子树大小。

`sum` 代表当前的子树和。

`tot` 用于确定每个点的下标，`root` 代表根节点的下标。

##### 宏定义

为了方便书写，用 ``ls`` 代替 ``t[p].l``，用 ``rs`` 代替 ``t[p].r``。即分别代表左右子树。

##### `pushup` 函数

```cpp
void pushup(int p)
{
    t[p].size = t[ls].size + t[rs].size + 1;
    t[p].sum = t[ls].sum + t[rs].sum + t[p].val;
}
```

类似线段树的 `pushup` ，用于在递归之后综合左右子树的信息并上传至节点 ``p`` 。

##### 按值分裂（`split_v`）

```cpp
void split_v(int p, int v, int &l, int &r)
{
    if (!p)
    {
        l = r = 0;
        return;
    }
    if (t[p].val <= v)
    {
        l = p;
        split_v(rs, v, rs, r);
    }
    else 
    {
        r = p;
        split_v(ls, v, l, ls);
    }
    pushup(p);
}
```

函数 `split_v(p,v,&l,&r)` 的含义为：

- 将树 `p` 按值 `v` 分裂成两棵子树`&l,&r`。
- 使得 `l` 中的所有值都不大于 `v`，`r` 中所有值都全部大于 `v`。

##### 按排名分裂（`split`）

```cpp
void split(int p, int v, int &l, int &r)
{
    if (!p)
    {
        l = r = 0;
        return;
    }
    if (t[ls].size + 1 <= v)
    {
        l = p;
        split(rs, v - (t[ls].size + 1), rs, r);
    }
    else
    {
        r = p;
        split(ls, v, l, ls);
    }
    pushup(p);
}
```



函数 `split(p,v,&l,&r)` 的含义为：

- 将树 `p` 按排名 `v` 分裂成两棵子树`&l,&r`。
- 使得 `l` 中的所有节点在原数组的位置都不大于 `v`，`r` 中所有节点在原数组的位置都全部大于 `v`。

##### 合并（`merge`）

```cpp
int merge(int x, int y)
{
    if (!x || !y)
        return x + y;
    if (t[x].rnd < t[y].rnd)
    {
        t[x].r = merge(t[x].r, y);
        pushup(x);
        return x;
    }
    else        
    {
        t[y].l = merge(x, t[y].l);
        pushup(y);
        return y;
    }
}
```

函数  `merge(x,y)` 的含义为：

将以 `x` 为根的 Treap 和以 `y` 为根的 Treap 合并为一个Treap。

那么根据定义，只需要按照 `rnd` 来分讨即可。

##### 创建新节点（`newnode`）

```cpp
int newnode(int v)
{
    int p = ++tot;
    t[p].val = t[p].sum = v;
    t[p].l = t[p].r = 0;
    t[p].rnd = rand() * rand();
    t[p].size = 1;
    return p;
}
```

这个没什么好说的，对节点的每个元素赋初值即可。

##### 建树（`build`）

```cpp
int build(int l, int r)
{
    if (l == r)
        return newnode(a[l]);
    int mid = (l + r) >> 1;
    return merge(build(l, mid), build(mid + 1, r));
}
```

`build` 函数类似线段树的 `build`，分治递归建树，每个节点先单独创建，然后合并上传即可。

##### 查询（`query`）

```cpp
int query(int l, int r)
{
    int t1 = 0, t2 = 0, t3 = 0;
    split(root, l - 1, t1, t2);
    split(t2, r - l + 1, t2, t3);
    int ans = t[t2].sum;
    root = merge(t1, merge(t2, t3));
    return ans;
}
```

如果要查询 $[l,r]$ 区间之和，那么只需要先将 Treap 按照排名 $l-1$ 分裂为 $t1,t2$，然后将 $t2$ 再次按照 $r-l+1$ （即区间的长度）分裂为 $t2,t3$，那么只需要统计 $t2$ 的数据就是最终的区间和。

##### 修改（`change`）

```cpp
void change(int k, int v)
{
    int t1 = 0, t2 = 0, t3 = 0;
    split(root, k - 1, t1, t2);
    split(t2, 1, t2, t3);
	t[t2].val = v;
    t[t2].sum = t[t2].size * v;
    root = merge(t1, merge(t2, t3));
}
```

同理，如果要修改第 $k$ 位的值，那么将 Treap 按照 $k-1$ 排名分裂一次，再按照 $1$ 排名分裂一次。之后修改 $t2$ 的值并合并即可。

##### 插入元素（`addx`）

```cpp
void addx(int v)
{
    int t1 = 0, t2 = 0, t3 = 0;
    split_v(root, v, t1, t3);
    t2 = newnode(v);
    root = merge(t1, merge(t2, t3));
}
```

`addx(v)` 的含义为：

在 Treap 中插入一个新元素 $v$。

所以我们只需要按照 $v$ 值分裂为 $t1,t3$，并开一个新 Treap $t2$ 并将 $v$ 作为其值。然后依次合并 $t1,t2,t3$ 即可。

##### 删除元素（`delet`）

```cpp
void delet(int v)
{
    int t1 = 0, t2 = 0, t3 = 0;
    split_v(root, v - 1, t1, t2);
    split_v(t2, v, t2, t3);
    t2 = merge(t[t2].l, t[t2].r);
    root = merge(merge(t1, t2), t3);
}
```

`delet(v)` 的含义为：

在 Treap 中找到 $v$ 并将其删除。

所以我们可以按照 $v-1$ 值分裂为 $t1,t2$，然后按照 $v$ 值分裂为 $t2,t3$。

那么我们只需要将 $v$ 删除（即将 $t2$ 的左右子树合并），然后依次合并 $t1,t2,t3$ 即可。

##### 求 `v` 的排名（`rank`）

```cpp
int rank(int v)
{
    int t1 = 0, t2 = 0, t3 = 0;
    split_v(root, v - 1, t1, t3);
    int ans = t[t1].size + 1;
    root = merge(t1, t3);
    return ans;
}
```

如果要求 $v$ 的排名，那么只需要按照 $v-1$ 值分裂为 $t1,t2$，那么 $v$ 的排名就为 $t1$ 的大小 $+1$。 

##### 查询最大最小值（`query_min,query_max`）

```cpp
int query_min(int p)
{
    while (ls)
    {
        p = ls;
    }
    return t[p].val;
}
int query_max(int p)
{
    while (rs)
    {
        p = rs;
    }
    return t[p].val;
}
```

由于 Treap 具有二叉搜索树的性质，那么显然以 $p$ 为根节点的 Treap的最左节点的值就为最小值，最右节点的值就为最大值。

如果要求解区间的最大最小值，可以先将其按排名分裂，然后对其中某个 Treap 求解即可。

##### 求排名为 `k` 的值（`ith`）

```cpp
int ith(int k)
{
    int t1 = 0, t2 = 0, t3 = 0;
    split(root, k, t1, t3);
    int ans = query_max(t1);
    root = merge(t1, t3);
    return ans;
}
```

显然只需要按照 $k$ 排名分裂为 $t1,t2$。那么答案就是 $t1$ 的最大值。

##### 前驱后继（`get_pre,get_nxt`）

```cpp
int get_pre(int v)
{        
    int t1 = 0, t2 = 0, t3 = 0;
    split_v(root, v - 1, t1, t3);
    int ans = query_max(t1);
    root = merge(t1, t3);
    return ans;
}
int get_nxt(int v)
{
    int t1 = 0, t2 = 0, t3 = 0;
    split_v(root, v, t1, t3);
    int ans = query_min(t3);
    root = merge(t1, t3);
    return ans;
}
```

如上，同理按照值分裂然后求取最大最小值即可。

#### 完整代码

```cpp
struct FHQ_treap
{
#define ls t[p].l
#define rs t[p].r
    struct Point
    {
        int l, r;
        int val, rnd;
        int size, sum;
    } t[MaxN];
    int tot = 0, root = 0;
    void pushup(int p)
    {
        t[p].size = t[ls].size + t[rs].size + 1;
        t[p].sum = t[ls].sum + t[rs].sum + t[p].val;
    }
    Point pushup(Point now, Point l, Point r)
    {
        now.size = l.size + r.size + 1;
        return now;
    }
    int newnode(int v)
    {
        int p = ++tot;
        t[p].val = t[p].sum = v;
        t[p].l = t[p].r = 0;
        t[p].rnd = rand() * rand();
        t[p].size = 1;
        return p;
    }
    void split_v(int p, int v, int &l, int &r)
    {
        if (!p)
        {
            l = r = 0;
            return;
        }
        if (t[p].val <= v)
        {
            l = p;
            split_v(rs, v, rs, r);
        }
        else
        {
            r = p;
            split_v(ls, v, l, ls);
        }
        pushup(p);
    }
    void split(int p, int v, int &l, int &r)
    {
        if (!p)
        {
            l = r = 0;
            return;
        }
        if (t[ls].size + 1 <= v)
        {
            l = p;
            split(rs, v - (t[ls].size + 1), rs, r);
        }
        else
        {
            r = p;
            split(ls, v, l, ls);
        }
        pushup(p);
    }
    int merge(int x, int y)
    {
        if (!x || !y)
            return x + y;
        if (t[x].rnd < t[y].rnd)
        {
            t[x].r = merge(t[x].r, y);
            pushup(x);
            return x;
        }
        else
        {
            t[y].l = merge(x, t[y].l);
            pushup(y);
            return y;
        }
    }
    int build(int l, int r)
    {
        if (l == r)
            return newnode(a[l]);
        int mid = (l + r) >> 1;
        return merge(build(l, mid), build(mid + 1, r));
    }
    int query(int l, int r)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split(root, l - 1, t1, t2);
        split(t2, r - l + 1, t2, t3);
        int ans = t[t2].sum;
        root = merge(t1, merge(t2, t3));
        return ans;
    }
    void change(int k, int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split(root, k - 1, t1, t2);
        split(t2, 1, t2, t3);
        t[t2].val = v;
        t[t2].sum = t[t2].size * v;
        root = merge(t1, merge(t2, t3));
    }
    void addx(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v, t1, t3);
        t2 = newnode(v);
        root = merge(t1, merge(t2, t3));
    }
    void delet(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v - 1, t1, t2);
        split_v(t2, v, t2, t3);
        t2 = merge(t[t2].l, t[t2].r);
        root = merge(merge(t1, t2), t3);
    }
    int rank(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v - 1, t1, t3);
        int ans = t[t1].size + 1;
        root = merge(t1, t3);
        return ans;
    }
    int query_min(int p)
    {
        while (ls)
        {
            p = ls;
        }
        return t[p].val;
    }
    int query_max(int p)
    {
        while (rs)
        {
            p = rs;
        }
        return t[p].val;
    }
    int ith(int k)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split(root, k, t1, t3);
        int ans = query_max(t1);
        root = merge(t1, t3);
        return ans;
    }
    int get_pre(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v - 1, t1, t3);
        int ans = query_max(t1);
        root = merge(t1, t3);
        return ans;
    }
    int get_nxt(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v, t1, t3);
        int ans = query_min(t3);
        root = merge(t1, t3);
        return ans;
    }
    void dfs(int p)
    {
        if (!p)
            return;
        dfs(ls);
        dfs(rs);
    }
} Tree;
```



## 题目

### P3369 【模板】普通平衡树

平衡树模板题。

```cpp
// #pragma GCC optimize(1, 2, 3, "Ofast", "inline")
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
#define ONLINE_JUDGE
// #define MULTI_CASES
#define endl '\n'
const int MaxN = 2e5 + 100;
const int INF = 1e9;
const int mod = 212370440130137957ll;
int T = 1, N, M;
int a[MaxN];
struct FHQ_treap
{
#define ls t[p].l
#define rs t[p].r
    struct Point
    {
        int l, r;
        int val, rnd;
        int size, sum;
    } t[MaxN];
    int tot = 0, root = 0;
    void pushup(int p)
    {
        t[p].size = t[ls].size + t[rs].size + 1;
        t[p].sum = t[ls].sum + t[rs].sum + t[p].val;
    }
    Point pushup(Point now, Point l, Point r)
    {
        now.size = l.size + r.size + 1;
        return now;
    }
    int newnode(int v)
    {
        int p = ++tot;
        t[p].val = t[p].sum = v;
        t[p].l = t[p].r = 0;
        t[p].rnd = rand() * rand();
        t[p].size = 1;
        return p;
    }
    void split_v(int p, int v, int &l, int &r)
    {
        if (!p)
        {
            l = r = 0;
            return;
        }
        if (t[p].val <= v)
        {
            l = p;
            split_v(rs, v, rs, r);
        }
        else
        {
            r = p;
            split_v(ls, v, l, ls);
        }
        pushup(p);
    }
    void split(int p, int v, int &l, int &r)
    {
        if (!p)
        {
            l = r = 0;
            return;
        }
        if (t[ls].size + 1 <= v)
        {
            l = p;
            split(rs, v - (t[ls].size + 1), rs, r);
        }
        else
        {
            r = p;
            split(ls, v, l, ls);
        }
        pushup(p);
    }
    int merge(int x, int y)
    {
        if (!x || !y)
            return x + y;
        if (t[x].rnd < t[y].rnd)
        {
            t[x].r = merge(t[x].r, y);
            pushup(x);
            return x;
        }
        else
        {
            t[y].l = merge(x, t[y].l);
            pushup(y);
            return y;
        }
    }
    int build(int l, int r)
    {
        if (l == r)
            return newnode(a[l]);
        int mid = (l + r) >> 1;
        return merge(build(l, mid), build(mid + 1, r));
    }
    int query(int l, int r)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split(root, l - 1, t1, t2);
        split(t2, r - l + 1, t2, t3);
        int ans = t[t2].sum;
        root = merge(t1, merge(t2, t3));
        return ans;
    }
    void change(int k, int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split(root, k - 1, t1, t2);
        split(t2, 1, t2, t3);
        t[t2].val = v;
        t[t2].sum = t[t2].size * v;
        root = merge(t1, merge(t2, t3));
    }
    void addx(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v, t1, t3);
        t2 = newnode(v);
        root = merge(t1, merge(t2, t3));
    }
    void delet(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v - 1, t1, t2);
        split_v(t2, v, t2, t3);
        t2 = merge(t[t2].l, t[t2].r);
        root = merge(merge(t1, t2), t3);
    }
    int rank(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v - 1, t1, t3);
        int ans = t[t1].size + 1;
        root = merge(t1, t3);
        return ans;
    }
    int query_min(int p)
    {
        while (ls)
        {
            p = ls;
        }
        return t[p].val;
    }
    int query_max(int p)
    {
        while (rs)
        {
            p = rs;
        }
        return t[p].val;
    }
    int ith(int k)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split(root, k, t1, t3);
        int ans = query_max(t1);
        root = merge(t1, t3);
        return ans;
    }
    int get_pre(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v - 1, t1, t3);
        int ans = query_max(t1);
        root = merge(t1, t3);
        return ans;
    }
    int get_nxt(int v)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(root, v, t1, t3);
        int ans = query_min(t3);
        root = merge(t1, t3);
        return ans;
    }
    void dfs(int p)
    {
        if (!p)
            return;
        dfs(ls);
        dfs(rs);
    }
} Tree;
inline void Solve()
{
    cin >> N;
    for (int i = 1; i <= N; i++)
    {
        int opt, x;
        cin >> opt >> x;
        if (opt == 1)
            Tree.addx(x);
        if (opt == 2)
            Tree.delet(x);
        if (opt == 3)
            cout << Tree.rank(x) << endl;
        if (opt == 4)
            cout << Tree.ith(x) << endl;
        if (opt == 5)
            cout << Tree.get_pre(x) << endl;
        if (opt == 6)
            cout << Tree.get_nxt(x) << endl;
    }
}
signed main()
{
#ifndef ONLINE_JUDGE
    freopen(".in", "r", stdin);
    freopen(".out", "w", stdout);
#endif
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    srand(time(0));
#ifdef MULTI_CASES
    cin >> T;
    while (T--)
#endif
        Solve();
    // fclose(stdin);
    // fclose(stdout);
    return 0;
}

```

### P3391 【模板】文艺平衡树

给定一个序列，然后进行 $m$ 次翻转区间的操作，求最终的序列。$m\le 10^5$

显然此题可以使用 FHQ-Treap 进行区间操作。

题目的核心操作是 `reverse(l,r)`，即翻转区间 $[l,r]$。显然我们可以考虑将其分裂为 $[1,l-1],[l,r],[r+1,n]$ 三个区间。然后递归交换 $[l,r]$ 区间的左右子树即可。但是显然其时间复杂度 $O(n\times \log_2 n)$ 甚至比不上直接暴力。

考虑优化，我们可以使用线段树中常用的懒标记来优化，对于每次操作，仅翻转当前节点的左右儿子，然后将懒标记分别下传至左右子树。由于翻转两次的结果就相当于没有翻转，所以 `rev_tag` 可以通过异或来修改。

但是，如果我们调换左右儿子，那么其将不符合 Treap 的性质。

不难发现，此题并没有对权值有任何要求，所以我们分裂的时候可以按照排名来分裂合并，这样的分裂方式不符合 $BST$ 的性质，但可以正确的维护中序遍历。

所有操作之后，中序遍历输出答案即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
// #define MULTI_CASES
#define ll long long
#define int ll
#define endl '\n'
#define vi vector<int>
#define PII pair<int, int>
const int MaxN = 2e5 + 100;
const int INF = 1e9;
const int mod = 1e9 + 7;
int T = 1, N, M;
int a[MaxN];
struct FHQ_Treap
{
#define ls t[p].l
#define rs t[p].r
    struct Point
    {
        int l, r;
        int val, rnd;
        int rev_tag;
        int siz;
    } t[MaxN];
    int tot = 0, root = 0;
    void pushdown(int p)
    {
        if (t[p].rev_tag)
        {
            swap(ls, rs);
            if (ls)
                t[ls].rev_tag ^= 1;
            if (rs)
                t[rs].rev_tag ^= 1;
            t[p].rev_tag = 0;
        }
    }
    void pushup(int p)
    {
        t[p].siz = t[ls].siz + t[rs].siz + 1;
    }
    void split(int p, int v, int &l, int &r)
    {
        if (!p)
        {
            l = r = 0;
            return;
        }
        pushdown(p);
        if (t[ls].siz + 1 <= v)
        {
            l = p;
            split(rs, v - t[ls].siz - 1, rs, r); // 修改：v 要减去左子树大小和当前节点大小
        }
        else
        {
            r = p;
            split(ls, v, l, ls);
        }
        pushup(p); // 添加：更新节点大小
    }
    int merge(int x, int y)
    {
        if (!x || !y)
            return x + y;
        pushdown(x);
        pushdown(y);
        if (t[x].rnd < t[y].rnd)
        {
            t[x].r = merge(t[x].r, y);
            pushup(x);
            return x;
        }
        else
        {
            t[y].l = merge(x, t[y].l);
            pushup(y);
            return y;
        }
    }
    int newnode(int x)
    {
        int p = ++tot;
        t[p].siz = 1;
        t[p].l = t[p].r = 0;
        t[p].rnd = rand() * rand();
        t[p].val = x;
        return p;
    }
    void dfs(int p)
    {
        if (!p)
            return;
        pushdown(p);
        dfs(ls);
        cout << t[p].val << " ";
        dfs(rs);
    }
    void reverse(int l, int r)
    {
        int t1 = 0, t2 = 0, t3 = 0;
        split(root, l - 1, t1, t2);
        split(t2, r - l + 1, t2, t3);
        t[t2].rev_tag ^= 1;
        root = merge(t1, merge(t2, t3));
    }
} Tree;
inline void Solve()
{
    cin >> N >> M;
    for (int i = 1; i <= N; i++)
    {
        Tree.root = Tree.merge(Tree.root, Tree.newnode(i));
    }
    for (int i = 1; i <= M; i++)
    {
        int l, r;
        cin >> l >> r;
        Tree.reverse(l, r);
    }
    Tree.dfs(Tree.root);
}
signed main()
{
#ifndef ONLINE_JUDGE
    freopen(".in", "r", stdin);
    freopen(".out", "w", stdout);
#endif
    ios::sync_with_stdio(0);
    cin.tie(nullptr), cout.tie(nullptr);
    srand(time(0)); // 添加：初始化随机数种子
#ifdef MULTI_CASES
    cin >> T;
    while (T--)
#endif
        Solve();
    return 0;
}
```



