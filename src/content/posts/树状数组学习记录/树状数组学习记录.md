---
title: 树状数组学习记录
published: 2025-10-15
description: 记录树状数组这一数据结构的相关知识、代码及例题题解。
tags: ['算法', '数据结构', '学习记录']
category: 学习笔记
draft: false
---
# 树状数组1
树状数组是一种可以实现 **单点修改和区间查询** 的数据结构，时间复杂度均为 $O(\log n)$。

相比同样可以实现区间修改的线段树，树状数组只能实现单点修改和区间查询，不过代码远比线段树少，且常数也更小，所以很有必要掌握。

## 基本原理
树状数组的基本原理是将一段数组 $[1,n]$ 拆分为 **不多于 $\log n$** 段区间，要求这 $\log n$ 段区间是已知的。这样我们就可以通过合并这 $\log n$ 段区间求解出答案。

![图示](./fenwick.svg)

那么我们可以用一个数组 $t_i$ 来表示存储一段右边界是 $x$ 的区间信息，那么如何确定其左边界呢？我们规定树状数组中，$t_i$ 表示的区间的长度为 $2^k$，其中：
- $k$ 表示 $i$ 的二进制中最低的 ``1`` 所在的位数
- 那么 $2^k$ 显然就是 $i$ 的二进制中最低的 ``1`` 及后面所有的 ``0`` 组成的二进制数。

我们规定 $x$ 的二进制最低位 ``1`` 及其后面所有的 ``0`` 组成的数为 $lowbit(x)$，那么 $t_x$ 表示的区间就是 $[x-lowbit(x)+1,x]$。

### lowbit计算方法
首先给出式子：
$$lowbit(x)=x\& (-x)$$
这个式子的原理为：首先由于 ``-x=~x+1``（即按位取反再加一），设 $x$ 的原二进制编码为 ``(...)10...00``，取反之后得到 ``[...]01...11``，加 `1` 后得到 ``[...]10...00``，注意这里的 `(...)` 和 `[...]` 完全相反，所以得出 ``x & -x =(...)10...00 & [...]10...00 = 10...00``，也就是我们要求的 `lowbit`。

### 区间查询
考虑求解 $[l,r]$ 之和，我们可以将其转化为求解 $sum(r)-sum(l-1)$，（$sum(x)$ 表示区间 $[1,x]$ 的和）。

那么现在我们只需要考虑如何求解 $sum(x)$ 即可。

我们可以将区间 $[1,x]$ 拆分为不多于 $\log n$ 段区间，那么怎么拆分呢？显然我们可以利用刚才的 `lowbit` 来求解：
- 首先从 $t_x$ 开始，那么我们已经求解到了区间 $[x-lowbit(x)+1,x]$。
- 之后我们令 $x\leftarrow x-lowbit(x)$，重复以上过程。
- 如果 $x=0$，说明已经跳到了尽头，循环结束。
- 过程中只需要把所有经过的 $t_x$ 合并即可。

```cpp
int sum(int x){
    int res=0;
    while(x){
        res+=t[x];
        x-=lowbit(x);
    }
    return res;
}
```
### 单点修改
考虑如何单点修改 $a_x$。

我们可以参考构建完成的树状数组图，不难发现，单点修改 $a_x$ 影响的 $t_y$ 在一条链上，所以我们可以从 $x$ 开始往他的父亲节点跳，直至跳到根节点为止。

设数组 $a$ 的长度为 $n$，我们可以这样修改 $a_x$：
- 初始设定 $x'=x$。
- 修改 $t_{x'}$。
- 令 $x'\leftarrow x'+lowbit(x')$。
- 如果 $x'>n$，终止循环即可。

```cpp
void add(int x,int y){
    a[x]+=y;
    while(x<=N){
        t[x]+=y;
        x+=lowbit(x);
    }
}
```
## 一些性质
- 树状数组的空间复杂度是 $O(N)$
- 树状数组的两种操作的时间复杂度都是 $O(\log N)$
- 树状数组维护的信息必须满足**交换律和可差分**。
## Code
```cpp
struct node
{
#define lowbit(x) (x & (-x))
    int t[MaxN];
    void init()
    {
        memset(t, 0, sizeof t);
        for (int i = 1; i <= N; i++)
        {
            for (int j = i - lowbit(i) + 1; j <= i; j++)
            {
                t[i] += a[j];
            }
        }
    }
    void add(int x, int y)
    {
        a[x] += y;
        while (x <= N)
        {
            t[x] += y;
            x += lowbit(x);
        }
    }
    int sum(int x)
    {
        int res = 0;
        while (x)
        {
            res += t[x];
            x -= lowbit(x);
        }
        return res;
    }
    int query(int x,int y){
        return sum(y)-sum(x-1);
    }
    void print(){
        for(int i=1;i<=N;i++){
            cerr<<t[i]<<" ";
        }
        cerr<<endl;
    }
}Tree;
```
# 树状数组2（区间修改+单点查询）
我们可以利用差分来求解。

为了求解区间修改，我们考虑数组 $a$ 的差分数组 $d$，其中 $d_i=a_{i}-a_{i-1}$。

那么区间修改操作（即修改 $[l,r]$ 的值），我们只需要更改 $d_l\leftarrow d_l+k,d_{r+1}\leftarrow d_{r+1}-k$。

同理，单点查询操作（即查询 $a_x$ 的值），我们只需要求解前 $x$ 个 $d_i$ 的和即可。

那么我们只需要用树状数组维护差分数组 $d_i$ 求解即可。